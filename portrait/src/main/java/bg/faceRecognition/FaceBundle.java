package bg.faceRecognition;

import java.io.File;
import java.io.Serializable;
import java.util.List;

/**
 * The face-space bundle generated by  EigenFaceComputation. This bundle
 * has all the relevant information to try to match an image The computation to
 * be done (to find the submitted image in this bundles' face-space) is quite
 * fast. For more about the algorithm, consult (<a href=
 * "http://www.cs.ucsb.edu/~mturk/Papers/mturk-CVPR91.pdf">http://www.cs.ucsb.edu/~mturk/Papers/mturk-CVPR91.pdf</a>)
 *
 * Each FaceBundle contains sixteen images and their identifying string. <br>
 *  This object is serializable, therefere its possible to cache
 * these face-spaces thus eliminating the computation process in  EigenFaceComputation.
 *
  */
public class FaceBundle implements Serializable, Comparable<FaceBundle> {

	
	private static final long serialVersionUID = 1L;
	private double[] avgFace = null;
	private double[] cmpFace = null;
	private double[][] eigVector = null;
	private double[][] wk = null;
	private List<File> listFiles = null;
	private transient double distanceMin = Double.MAX_VALUE;
	/**
	 * The length of the vector-images stored in the face-space bundle. The
	 * submitted image must be of the same length or greater (if its greater
	 * only length will be considered).
	 */
	public int length = Integer.MIN_VALUE;
	private transient boolean computed = false;
	private transient int idx = Integer.MAX_VALUE;

	/**
	 * The face-space object containing:
	 *
	 * <ol>
	 * <li>An average face array.
	 * <li>Eigenspace of images
	 * <li>Face space of images
	 * <li>List of names identifying each image
	 * </ol>
	 *
	 * @param avgF
	 *            Average face (used to normalize the image to be matched against)
	 * @param wk
	 *            The eigenface componenets (projected onto the eigenspace)
	 * @param eigV
	 *            The eigenspace (onto which the matched image will be projected
	 *            too)
	 * @param id
	 *            A String array representing each of the sixteen images represented
	 *            by this face-space.
	 *
	 */
	public FaceBundle(double[] avgF, double wk[][], double[][] eigV, List<File> listF) {

		this.avgFace = avgF;
		this.wk = wk;
		this.eigVector = eigV;
		this.length = avgFace.length;
		this.listFiles = listF;
	}

	
	public double submitFace(byte[] face) {		
		return this.submitFace( UtilArray.toDouble(face));
	}

	
	public double submitFace(int[] face) {
		return this.submitFace( UtilArray.toDouble(face));
	}

	/**
	 * Submit an image of matching against the face-space. 
	 * @param face
	 *            The vector-array of the image. The image must be of <b>length</b>
	 *
	 */
	public double submitFace(double[] face) {

		this.cmpFace = face;
		compute();
		double distance = this.distanceMin();
		return distance;
	}

	/**
	 * Clear the submitted image from the face-space object.
	 */
	public void clearFace() {

		cmpFace = null;
		computed = false;
		idx = Integer.MAX_VALUE;
		distanceMin = Double.MAX_VALUE;
	}

	/**
	 * The distance of how far away the submitted image is in this face-space
	 * object. Consult <code>getID()</code> for the name of the image that it was
	 * most near too.
	 *
	 * @return >= 0 or if no image has been submitted: <code>Double.MAX_VALUE</code>
	 */
	public double distanceMin() {

		return distanceMin;
	}

	

	public String getFileName() {
		return this.listFiles.get(idx).getName();

	}

	/**
	 * Compare this face-space bundle to another. If this bundle has a smaller
	 * distance than the other, -1 is returned. 1 if its opposite. <b>NOTE</b>:
	 * There is no checking if the other face-space bundle has computed its values
	 * for the same image.
	 */
	public int compareTo(FaceBundle fb) {

		if (fb.distanceMin > distanceMin) {
			return 1;
		} else if (fb.distanceMin < distanceMin) {
			return -1;
		} else {
			return 0;
		}
	}

	
	public String toString() {

		if (computed) {
			return "[" + listFiles.get(idx).getName() + "] with " + distanceMin;
		}else {
			return "No image supplied";
		}
			
		
	}

	/**
	 * Do the computation..
	 *
	 */
	private void compute() {

		double[] inputFace = new double[length];
		int nrfaces = eigVector.length;
		int MAGIC_NR = wk[0].length;
		int j, pix, image;

		computed = false;
		System.arraycopy(cmpFace, 0, inputFace, 0, length);

		for (pix = 0; pix < inputFace.length; pix++) {
			inputFace[pix] = inputFace[pix] - avgFace[pix];
		}

		double[] input_wk = new double[MAGIC_NR];
		double temp = 0;
		/* Subtract the image from the average image */
		for (j = 0; j < MAGIC_NR; j++) {
			temp = 0.0;
			for (pix = 0; pix < length; pix++)
				temp += eigVector[j][pix] * inputFace[pix];

			input_wk[j] = Math.abs(temp);
		}

		/*
		 * Find the minimun distance from the input_wk as compared to wk
		 */

		double[] distance = new double[MAGIC_NR];
		double[] minDistance = new double[MAGIC_NR];
		idx = 0;
		for (image = 0; image < nrfaces; image++) {
			temp = 0.0;
			for (j = 0; j < MAGIC_NR; j++) {
				distance[j] = Math.abs(input_wk[j] - wk[image][j]);
			}
			if (image == 0) {
				System.arraycopy(distance, 0, minDistance, 0, MAGIC_NR);
			}
			if (UtilArray.sum(minDistance) > UtilArray.sum(distance)) {

				this.idx = image;
				System.arraycopy(distance, 0, minDistance, 0, MAGIC_NR);
			}
		}

		/*
		 * Normalize our minimum distance.
		 */

		if (UtilArray.max(minDistance) > 0.0)
			UtilArray.divide(minDistance, UtilArray.max(minDistance));

		distanceMin = UtilArray.sum(minDistance);

		computed = true;

	}

}
